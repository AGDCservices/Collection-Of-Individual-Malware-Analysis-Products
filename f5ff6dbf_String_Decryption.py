#decrypt hardcoded strings in unpacked qbot malware. sha256 f5ff6dbf5206cc2db098b41f5af14303f6dc43e36c5ec02604a50d5cfecf4790
#@author https://AGDCServices.com
#@category AGDCservices
#@keybinding
#@menupath
#@toolbar


def main():

    #
    # declare target addresses for multiple crypto functions
    #

    # configuration values pulled from function where arg is pushed onto stack
    targetFuncEa1 = 0x406523
    keyEa1 = 0x410120
    ctEa1 = 0x40b930
    ctLen1 = 0x36f5


    # configuration values pulled from function where arg is passed via register
    targetFuncEa2 = 0x4065b7
    paramReg = 'eax'
    keyEa2 = 0x410120
    ctEa2 = 0x40b930
    ctLen2 = 0x36f5

    #
    #
    #



    #convert input parameters to ghidra objects
    targetFuncEa1 = toAddr(targetFuncEa1)
    keyEa1 = toAddr(keyEa1)
    ctEa1 = toAddr(ctEa1)
    
    targetFuncEa2 = toAddr(targetFuncEa2)
    keyEa2 = toAddr(keyEa2)
    ctEa2 = toAddr(ctEa2)



    failList = []
    #
    # decrypt strings for targetFuncEa1
    #

    # decrypt entire configuration block
    i = 0
    ptStr1 = ''
    ptDict1 = {}
    while (i < (ctLen1 - 1)):
        pt = Decrypt_String(keyEa1, ctEa1, i)
        ptLen = len(pt)
        ptStr1 += '{}: {}\n'.format(hex(i), pt)
        ptDict1[i] = pt
        i += (ptLen + 1)


    # add comments for all xrefs
    for xrefEa in Get_Call_Xrefs_To(targetFuncEa1):
        paramInstr = Get_Prev_Target_Instruction(getInstructionAt(xrefEa), 'push', 1, MAX_INSTRUCTIONS = 20)
        if paramInstr == None:
            failList.append(xrefEa)
            continue

        paramValue = Get_Operand_As_Immediate_Value(paramInstr, 0)
        try:
            pt = ptDict1[paramValue]
            setEOLComment(xrefEa, pt)
        except:
            failList.append(xrefEa)


    #
    # decrypt strings for targetFuncEa2
    #

    # decrypt entire configuration block
    i = 0
    ptStr2 = ''
    ptDict2 = {}
    while (i < (ctLen2 - 1)):
        pt = Decrypt_String(keyEa2, ctEa2, i)
        ptLen = len(pt)
        ptStr2 += '{}: {}\n'.format(hex(i), pt)
        ptDict2[i] = pt
        i += (ptLen + 1)



    # add comments for all xrefs
    for xrefEa in Get_Call_Xrefs_To(targetFuncEa2):
        tmpEa = xrefEa
        for i in range(3):
            paramInstr = Get_Prev_Target_Instruction(getInstructionAt(tmpEa), 'mov', 1, MAX_INSTRUCTIONS = 20)

            if paramInstr == None: break
            if Get_Operand_As_String(paramInstr, 0).lower() == paramReg: break

            tmpEa = paramInstr.getAddress()
            paramInstr = None


        if paramInstr == None:
            failList.append(xrefEa)
            continue

        paramValue = Get_Operand_As_Immediate_Value(paramInstr, 1)
        try:
            pt = ptDict2[paramValue]
            setEOLComment(xrefEa, pt)
        except:
            failList.append(xrefEa)



    # print entire decrypted configuration block
    ptStrFinal = ''
    if ptStr1 == ptStr2:
        ptStrFinal = ptStr1
    else:
        ptStrFinal = '{}{}'.format(ptStr1, ptStr2)
        
    print('\n{} Decrypted Configuration Block {}\n'.format('='*10, '='*10))
    print(ptStrFinal)


    # print error locations to be manually resolved
    if len(failList) > 0:
        print('======= Error ========')

        for i in failList:
            print('could not resolve parameters for {}'.format(i))


def Decrypt_String(keyEa, ctEa, param1):
    '''
    return decrypted string
    '''


    result = ''
    i = 0
    while True:
        keyByte = Get_Bytes_String(keyEa.add((param1 + i) % 0x40), 1)
        ctByte = Get_Bytes_String(ctEa.add(param1 + i), 1)
        ptByte = ord(keyByte) ^ ord(ctByte)
        if ptByte == 0: break

        result += chr(ptByte)
        i += 1


    return result


def Get_Bytes_String(targetEa, nLen):
    '''
    gets the bytes from memory, treating as unsigned bytes
    ghidra treats read bytes as signed which is not what
    you normally want when reading memory, e.g. if you call
    getBytes on a byte 0xfe, you won't get 0xfe, you'll get -2
    this may not be an issue depending on what operation you
    are performing, or it may, e.g. reading a byte that is
    displayed as a negative value will fail when compared to
    the two's complement hex (-2 != 0xfe).  If you're using
    the byte to patch the program, it may work ok.

    returns result as a string
    '''

    signedList = list(getBytes(targetEa, nLen))
    unsignedList = []
    for curByte in signedList:
        if curByte < 0:
            uByte = (0xff - abs(curByte) + 1)
        else:
            uByte= curByte
        unsignedList.append(chr(uByte))

    return ''.join(unsignedList)

def Get_Call_Xrefs_To(targetEa):
    '''
    returns list of addresses which call the targetEa

    '''

    callEaList = []
    for ref in getReferencesTo(targetEa):
        if getInstructionAt(ref.getFromAddress()).getMnemonicString().lower() == 'call':
            callEaList.append(ref.getFromAddress())

    return callEaList


def Get_Prev_Target_Instruction(curInstr, mnem, N, MAX_INSTRUCTIONS = 9999):
    '''
    gets N'th previous target instruction from the curInstr
    function will only go back MAX_INSTRUCTIONS
    function will not search outside of current function if the
    current instruction is inside a defined function
    returns None on failure
    '''


    # get address set of current function to use in determining if prev instruction
    # is outside of current function
    try:
        funcBody = getFunctionContaining(curInstr.getAddress()).getBody()
    except:
        funcBody = None


    # get Nth prev instruction
    totalInstructionCount = 0
    targetInstructionCount = 0
    while (totalInstructionCount < MAX_INSTRUCTIONS) and (targetInstructionCount < N):
        curInstr = curInstr.getPrevious()

        if curInstr == None: break
        if funcBody != None:
            if funcBody.contains(curInstr.getAddress()) == False: break

        if curInstr.getMnemonicString().lower() == mnem.lower(): targetInstructionCount += 1

        totalInstructionCount += 1


    # return the results
    if targetInstructionCount == N:
        result = curInstr
    else:
        result = None

    return result


def Get_Operand_As_Immediate_Value(targetInstr, operandIndex):
    '''
    returns the value for the operandIndex operand of the target instruction
    if the target operand is not an immediate value, the function will attempt
    to find where the variable was previously set.  It will ONLY search within
    the current function to find where the variable was previously set.
    if operand value can not be determined, returns None
    operandIndex starts at 0
    '''

    # operand types are typically different if operand is
    # used in a call versus not a call and if there is a
    # reference or not
    OP_TYPE_IMMEDIATE = 16384
    OP_TYPE_NO_CALL_REG = 512
    OP_TYPE_NO_CALL_STACK = 4202496
    # global variables have numerous reference types
    # unsure how to differentiate the different types


    # error check
    if operandIndex >= targetInstr.getNumOperands():
        print('[*] Error in Get_Operand_As_Immediate_Value.  operandIndex is too large at {:s}'.format(targetInstr.getAddress().toString()))
        return None
    elif targetInstr.getNumOperands() == 0:
        return None


    # get address set of current function to use in determining
    # if prev instruction is outside of current function
    try:
        funcBody = getFunctionContaining(targetInstr.getAddress()).getBody()
    except:
        funcBody = None


    # find the actual operand value
    targetValue = None
    opType = targetInstr.getOperandType(operandIndex)
    # if operand is a direct number
    if opType == OP_TYPE_IMMEDIATE:
        targetValue = targetInstr.getOpObjects(operandIndex)[0].getValue()
    # else if operand is a register
    elif opType == OP_TYPE_NO_CALL_REG:
        regName = targetInstr.getOpObjects(operandIndex)[0].getName().lower()

        # search for previous location where register value was set
        curInstr = targetInstr
        while True:
            curInstr = curInstr.getPrevious()

            # check to make sure curInstr is valid
            if curInstr == None: break
            if funcBody != None:
                if funcBody.contains(curInstr.getAddress()) == False: break

            # check different variations of how register values get set
            curMnem = curInstr.getMnemonicString().lower()
            if (curMnem == 'mov') and (curInstr.getOperandType(0) == OP_TYPE_NO_CALL_REG):
                if curInstr.getOpObjects(0)[0].getName().lower() == regName:
                    if curInstr.getOperandType(1) == OP_TYPE_IMMEDIATE:
                        targetValue = curInstr.getOpObjects(1)[0].getValue()
                    elif curInstr.getOperandType(1) == OP_TYPE_NO_CALL_REG:
                        targetValue = Get_Operand_As_Immediate_Value(curInstr, 1)
                    break
            elif (curMnem == 'xor'):
                operand1 = curInstr.getOpObjects(0)[0]
                operand2 = curInstr.getOpObjects(1)[0]
                op1Type = curInstr.getOperandType(0)
                op2Type = curInstr.getOperandType(1)

                if (op1Type == OP_TYPE_NO_CALL_REG) and (op2Type == OP_TYPE_NO_CALL_REG):
                    if (operand1.getName().lower() == regName) and (operand2.getName().lower() == regName):
                        targetValue = 0
                        break
            elif (curMnem == 'pop') and (curInstr.getOperandType(0) == OP_TYPE_NO_CALL_REG):
                if curInstr.getOpObjects(0)[0].getName().lower() == regName:
                    # find previous push
                    # NOTE: assumes previous push corresponds to pop but
                    # will fail if there is a function call in-between
                    tmpCurInstr = curInstr.getPrevious()
                    while True:
                        # check to make sure tmpCurInstr is valid
                        if tmpCurInstr == None: break
                        if funcBody != None:
                            if funcBody.contains(tmpCurInstr.getAddress()) == False: break

                        if tmpCurInstr.getMnemonicString().lower() == 'push':
                            if tmpCurInstr.getOperandType(0) == OP_TYPE_IMMEDIATE:
                                targetValue = tmpCurInstr.getOpObjects(0)[0].getValue()
                            break

                    # break out of outer while loop
                    break
    # if operand is a stack variable
    elif opType == OP_TYPE_NO_CALL_STACK:
        stackOffset = targetInstr.getOperandReferences(operandIndex)[0].getStackOffset()

        # search for previous location where stack variable value was set
        curInstr = targetInstr
        while True:
            curInstr = curInstr.getPrevious()

            # check to make sure curInstr is valid
            if curInstr == None: break
            if funcBody != None:
                if funcBody.contains(curInstr.getAddress()) == False: break

            # find where stack variable was set
            curMnem = curInstr.getMnemonicString().lower()
            if (curMnem == 'mov') and (curInstr.getOperandType(0) == OP_TYPE_NO_CALL_STACK):
                if curInstr.getOperandReferences(0)[0].getStackOffset() == stackOffset:
                    if curInstr.getOperandType(1) == OP_TYPE_IMMEDIATE:
                        targetValue = curInstr.getOpObjects(1)[0].getValue()
                    break




    return targetValue

def Get_Operand_As_String(targetInstr, operandIndex):
    '''
    returns the value for the operandIndex operand of the
    target instruction treated as a string.
    operandIndex starts at 0

    If this is called on jumps or calls, the final
    address jumped to / called will be returned

    '''

    # error check
    if operandIndex >= targetInstr.getNumOperands():
        print('[*] Error in Get_Operand_As_String.  operandIndex is too large at {:s}'.format(targetInstr.getAddress().toString()))
        return None
    elif targetInstr.getNumOperands() == 0:
        return None


    operand = targetInstr.getOpObjects(operandIndex)[0]

    return operand.toString()


main()